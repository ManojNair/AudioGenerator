
import os
import base64
import time
import re 
import datetime
from pathlib import Path

# Semantic Kernel imports
from semantic_kernel import Kernel
from semantic_kernel.connectors.ai.open_ai import AzureChatCompletion
from semantic_kernel.functions import KernelArguments

# Azure Speech imports
from azure.cognitiveservices.speech import SpeechConfig, SpeechSynthesizer, AudioConfig, ResultReason, CancellationReason, SpeechSynthesisOutputFormat

# Load environment variables
from dotenv import load_dotenv
load_dotenv()

# Get configuration
api_key = os.getenv("AZURE_OPENAI_KEY")
azure_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
deployment_name = os.getenv("AZURE_OPENAI_MODEL_DEPLOYMENT")
api_version = os.getenv("AZURE_OPENAI_API_VERSION")

AZURE_SPEECH_ENDPOINT = os.getenv("AZURE_SPEECH_ENDPOINT")
AZURE_SPEECH_KEY = os.getenv("AZURE_SPEECH_KEY") 
AZURE_SPEECH_REGION = os.getenv("AZURE_SPEECH_REGION") 
AZURE_SPEECH_LANG = "en-US" # Default fallback

AZURE_SPEECH_VOICE_1 = "en-US-Emma2:DragonHDLatestNeural" 
AZURE_SPEECH_VOICE_2 = "en-US-Andrew3:DragonHDLatestNeural"   

tenant_id = os.getenv("AZURE_TENANT_ID")
client_id = os.getenv("AZURE_CLIENT_ID")
client_secret = os.getenv("AZURE_CLIENT_SECRET")

OUTPUT_FILENAME = "podcast.wav" # Default, will be timestamped later

# MIME type mappings (Generally constant)
MIME_TYPES = {
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".webp": "image/webp"
}

class ImageAnalysisPlugin:
    """Plugin for analyzing images and extracting data descriptions"""
    
    def __init__(self, kernel: Kernel):
        self.kernel = kernel
    
    @staticmethod
    def describe_image(local_image_path: str) -> str:
        """
        Analyzes and describes images in detail.
        Provide the full path to the image file you want to describe.
        """
        try:
            # Convert to Path object
            image_path = Path(local_image_path)
            # Double-check file exists
            if not image_path.exists():
                print(f"Error: Image file not found at {image_path}")
                return f"Error: Image file not found at {image_path}"
            else:
                print(f"Tool confirmed file exists at {image_path}")
            
            # Read and encode image to base64
            with open(image_path, "rb") as img_file:
                img_data = base64.b64encode(img_file.read()).decode("utf-8")
                file_size = os.path.getsize(image_path)
                print(f"Successfully read image file. Size: {file_size} bytes")
            
            # Get the MIME type
            extension = image_path.suffix.lower()
            mime_type = MIME_TYPES.get(extension, "application/octet-stream")
            print(f"Using MIME type: {mime_type}")
            
            # Format image content for Azure OpenAI
            image_content = f"data:{mime_type};base64,{img_data}"
            
            # For now, return a placeholder since we need to implement image analysis
            # In a full implementation, you would use Azure OpenAI's vision capabilities
            return f"Image file loaded successfully: {image_path.name}, Size: {file_size} bytes, Type: {mime_type}. Image content encoded as base64 for analysis."
            
        except Exception as e:
            print(f"Error in tool: {str(e)}")
            return f"Error processing image: {str(e)}"

class SSMLPlugin:
    """Plugin for SSML formatting and speech synthesis"""
    
    @staticmethod
    def format_ssml(dialogue_content: str) -> str:
        """
        Takes podcast dialogue text (expected to contain <voice> tags already)
        and wraps it in the necessary <speak> root element for Azure SSML,
        dynamically setting the xml:lang attribute based on the configured primary voice.
        It cleans up potential extra whitespace or markdown code fences.
        Provide the raw dialogue content generated by the scriptwriter.
        """
        print("SSML Formatter Tool: Received dialogue content.")
        ssml_body = str(dialogue_content).strip()

        # Remove potential markdown code fences added by LLM
        ssml_body = re.sub(r'^```xml\s*', '', ssml_body, flags=re.IGNORECASE | re.MULTILINE)
        ssml_body = re.sub(r'\s*```$', '', ssml_body, flags=re.MULTILINE)
        ssml_body = ssml_body.strip()

        lang_attribute = f'xml:lang="{AZURE_SPEECH_LANG}"'
        is_already_wrapped = ssml_body.startswith('<speak') and ssml_body.endswith('</speak>')
        has_correct_lang = lang_attribute in ssml_body[:150]

        if is_already_wrapped and has_correct_lang:
            print(f"SSML Formatter Tool: Input already correctly wrapped with {lang_attribute}.")
            return ssml_body
        elif is_already_wrapped and not has_correct_lang:
            print(f"SSML Formatter Tool: Input wrapped, but ensuring correct {lang_attribute}.")
            pattern = re.compile(r'(<speak[^>]*)(\s*xml:lang="[^"]*")?([^>]*>)', re.IGNORECASE)
            if pattern.search(ssml_body):
                ssml_body = pattern.sub(rf'\1 {lang_attribute}\3', ssml_body, count=1)
            else:
                ssml_body = ssml_body.replace('<speak', f'<speak {lang_attribute}', 1)
            return ssml_body
        else:
            print(f"SSML Formatter Tool: Wrapping dialogue content with {lang_attribute}.")
            ssml_full = f'<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" {lang_attribute}>\n{ssml_body}\n</speak>'
            return ssml_full

    @staticmethod
    def ssml_to_speech(ssml_input: str) -> str:
        """
        Converts a **complete and valid** SSML string (including the root <speak> tag
        with correct xml:lang, and <voice> tags defining multiple voices) into speech
        and saves it as a single WAV file. Provide the full, validated SSML string.
        Use the 'SSML Formatter Tool' first to ensure validity.
        """
        try:
            # Credentials check
            speech_config = SpeechConfig(subscription=AZURE_SPEECH_KEY, region=AZURE_SPEECH_REGION)
            speech_config.set_speech_synthesis_output_format(SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm)

            ssml_content = str(ssml_input)

            if not ssml_content.strip().startswith('<speak'):
                print(f"Warning in ssml_to_speech: Input SSML might be invalid (missing <speak> tag): {ssml_content[:100]}...")

            print(f"SSML to Speech Tool: Processing SSML (language should be embedded within): '{ssml_content[:150]}...'")
            print(f"Output will be saved to: {OUTPUT_FILENAME}")

            if not ssml_content:
                return "Error: No SSML content provided for speech synthesis."

            output_dir = os.path.dirname(OUTPUT_FILENAME)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir); print(f"Created output directory: {output_dir}")

            audio_config = AudioConfig(filename=OUTPUT_FILENAME)
            synthesizer = SpeechSynthesizer(speech_config=speech_config, audio_config=audio_config)

            print("Synthesizing SSML...")
            result = synthesizer.speak_ssml_async(ssml_content).get()

            del synthesizer; del audio_config; time.sleep(0.1)

            if result.reason == ResultReason.SynthesizingAudioCompleted:
                wait_time = 0
                while not (os.path.exists(OUTPUT_FILENAME) and os.path.getsize(OUTPUT_FILENAME) > 0) and wait_time < 5:
                    time.sleep(0.5); wait_time += 0.5
                if not (os.path.exists(OUTPUT_FILENAME) and os.path.getsize(OUTPUT_FILENAME) > 0):
                    return f"Error: Output file {OUTPUT_FILENAME} is missing or empty after synthesis completed."
                else:
                    print(f"SSML synthesis successful. File saved to {OUTPUT_FILENAME} ({os.path.getsize(OUTPUT_FILENAME)} bytes).")
                    return f"Speech synthesis successful. File saved at: {OUTPUT_FILENAME}"
            elif result.reason == ResultReason.Canceled:
                cancellation_details = result.cancellation_details
                error_message = f"SSML synthesis canceled. Reason: {cancellation_details.reason}"
                if cancellation_details.reason == CancellationReason.Error:
                    print(f"Cancellation Error Code: {cancellation_details.error_code}")
                    print(f"Cancellation Error Details: {cancellation_details.error_details}")
                    error_message += f" Error details: {cancellation_details.error_details}"
                print(error_message)
                if os.path.exists(OUTPUT_FILENAME):
                    try: os.remove(OUTPUT_FILENAME)
                    except OSError as remove_err: print(f"Warning: Could not remove partially created file {OUTPUT_FILENAME}: {remove_err}")
                return error_message
            else:
                error_message = f"Unexpected SSML synthesis result: {result.reason}"
                print(error_message)
                if os.path.exists(OUTPUT_FILENAME):
                    try: os.remove(OUTPUT_FILENAME)
                    except OSError as remove_err: print(f"Warning: Could not remove potentially invalid file {OUTPUT_FILENAME}: {remove_err}")
                return error_message

        except Exception as e:
            import traceback
            print(f"Error in ssml_to_speech function: {str(e)}")
            print(traceback.format_exc())
            if os.path.exists(OUTPUT_FILENAME):
                try: os.remove(OUTPUT_FILENAME)
                except OSError as remove_err: print(f"Warning: Could not remove file {OUTPUT_FILENAME} during exception handling: {remove_err}")
            return f"Error during SSML to speech processing: {str(e)}"

class BusinessAnalysisPlugin:
    """Plugin for business analysis and report generation"""
    
    def __init__(self, kernel: Kernel):
        self.kernel = kernel
    
    async def analyze_image_data(self, image_description: str) -> str:
        """
        Analyzes image description to extract business insights and create a structured report
        """
        prompt = f"""
        You are a meticulous business analyst skilled at interpreting data presented visually.
        
        Based on the following image description, perform a thorough business analysis:
        
        {image_description}
        
        Identify key insights, significant trends, important figures, and potential implications.
        Structure your findings as a written essay with:
        1. A clear 'Executive Summary' section summarizing the main points
        2. A detailed 'Analysis' section elaborating on the findings
        
        Focus on sales data, year-over-year growth, and state-by-state comparisons.
        """
        
        # Get the chat service from the kernel
        chat_service = self.kernel.get_service("chat")
        
        # Create arguments for the function
        args = KernelArguments(image_description=image_description)
        
        # Invoke the chat service
        result = await chat_service.invoke(prompt, args)
        
        return str(result)

class PodcastScriptPlugin:
    """Plugin for creating podcast scripts from business analysis"""
    
    def __init__(self, kernel: Kernel):
        self.kernel = kernel
    
    async def create_podcast_script(self, business_analysis: str) -> str:
        """
        Creates a podcast script from business analysis with proper voice tags
        """
        prompt = f"""
        You are a creative podcast script writer who specializes in making business analysis engaging and easy to understand.
        
        Based on the following business analysis, create a natural-sounding podcast script:
        
        {business_analysis}
        
        **Formatting Requirements:**
        - Use `<voice name='{AZURE_SPEECH_VOICE_1}'>` tags for Host 1
        - Use `<voice name='{AZURE_SPEECH_VOICE_2}'>` tags for Host 2
        - Create a monologue that flows naturally and makes the analysis easy for listeners to grasp
        - Focus on key insights about sales across different states
        - Make it conversational and engaging
        - Wrap the entire script in `<speak>` tags
        
        The script should be ready for audio generation with proper SSML formatting.
        """
        
        # Get the chat service from the kernel
        chat_service = self.kernel.get_service("chat")
        
        # Create arguments for the function
        args = KernelArguments(business_analysis=business_analysis)
        
        # Invoke the chat service
        result = await chat_service.invoke(prompt, args)
        
        return str(result)

async def main():
    """Main function to orchestrate the podcast generation workflow"""
    
    # ==================================================================
    print("\nConfiguration values:")
    print(f"Endpoint: {azure_endpoint}")
    print(f"Deployment: {deployment_name}")
    print(f"API Key length: {len(api_key) if api_key else 0}")
    print(f"Api version: {api_version}")
    
    # Initialize Semantic Kernel
    kernel = Kernel()
    
    # Add Azure OpenAI chat service
    chat_service = AzureChatCompletion(
        service_id="chat",
        deployment_name=deployment_name,
        endpoint=azure_endpoint,
        api_key=api_key,
        api_version=api_version
    )
    kernel.add_service(chat_service)
    
    print("\nTesting Azure OpenAI connection...")
    try:
        # Test the connection
        test_args = KernelArguments(message="Hello! This is a test message.")
        response = await chat_service.invoke("Hello! This is a test message.", test_args)
        print("Connection successful!")
    except Exception as e:
        print(f"Error: {str(e)}")
        return
    # ==================================================================

    # Derive language automatically from the first voice for SSML tag
    try:
        if AZURE_SPEECH_VOICE_1 and isinstance(AZURE_SPEECH_VOICE_1, str) and AZURE_SPEECH_VOICE_1.startswith('<'):
            print(f"Warning: AZURE_SPEECH_VOICE_1 seems to contain a placeholder '{AZURE_SPEECH_VOICE_1}'. Using default language '{AZURE_SPEECH_LANG}'. Please replace the placeholder.")
        elif AZURE_SPEECH_VOICE_1 and isinstance(AZURE_SPEECH_VOICE_1, str):
            parts = AZURE_SPEECH_VOICE_1.split('-')
            if len(parts) >= 2:
                AZURE_SPEECH_LANG = f"{parts[0]}-{parts[1]}"
            else:
                print(f"Warning: Could not reliably determine language from voice '{AZURE_SPEECH_VOICE_1}'. Using default '{AZURE_SPEECH_LANG}'.")
        elif AZURE_SPEECH_VOICE_1 is None:
            print(f"Warning: AZURE_SPEECH_VOICE_1 is not set. Using default language '{AZURE_SPEECH_LANG}'.")
    except Exception as e:
        print(f"Warning: Error parsing voice name for language '{AZURE_SPEECH_VOICE_1}': {e}. Using default '{AZURE_SPEECH_LANG}'.")

    # ==================================================================
    LOCAL_IMAGE_PATH = "pbi_image.jpg"
    OUTPUT_FILENAME = "podcast" # todo - change to use the name of input image file
    timestamp = int(datetime.datetime.now().timestamp())
    OUTPUT_FILENAME = f"{OUTPUT_FILENAME}_{timestamp}.wav"
    # ==================================================================    
    
    print(f"Azure Speech Key: {AZURE_SPEECH_KEY}")
    print(f"Azure Speech Region: {AZURE_SPEECH_REGION}")
    if not AZURE_SPEECH_KEY:
        print("Warning: AZURE_SPEECH_KEY environment variable not found or empty.")
    if not AZURE_SPEECH_REGION:
        print("Warning: AZURE_SPEECH_REGION environment variable not found or empty.")

    print(f"Host 1 Voice: {AZURE_SPEECH_VOICE_1}")
    print(f"Host 2 Voice: {AZURE_SPEECH_VOICE_2}")
    print(f"Derived SSML Language: {AZURE_SPEECH_LANG}")
    print(f"Output Base Filename: {OUTPUT_FILENAME}")
    print(f"----------------------------")

    # Pre-flight check for output directory
    output_dir = os.path.dirname(OUTPUT_FILENAME)
    if output_dir and not os.path.exists(output_dir):
        print(f"Warning: Output directory '{output_dir}' does not exist. Attempting to create it.")
        try:
            os.makedirs(output_dir, exist_ok=True)
            print(f"Successfully created output directory: {output_dir}")
        except OSError as e:
            print(f"Error: Failed to create output directory '{output_dir}': {e}")
            raise
    # --- End Checks ---
    # ==================================================================  

    # ======================= PLUGINS =======================
    image_analysis_plugin = ImageAnalysisPlugin(kernel)
    business_analysis_plugin = BusinessAnalysisPlugin(kernel)
    podcast_script_plugin = PodcastScriptPlugin(kernel)
    ssml_plugin = SSMLPlugin()
    # ==================================================================  
    
    print(f"\n--- Starting Semantic Kernel Workflow ---")
    print(f"Image Path: {LOCAL_IMAGE_PATH}")
    print(f"Output Audio Path: {OUTPUT_FILENAME}")
    print(f"--> Derived SSML Language: {AZURE_SPEECH_LANG}")
    print(f"----------------------------\n")

    try:
        # Step 1: Analyze the image
        print("Step 1: Analyzing image...")
        image_description = image_analysis_plugin.describe_image(LOCAL_IMAGE_PATH)
        print(f"Image analysis completed: {len(image_description)} characters")
        
        # Step 2: Perform business analysis
        print("Step 2: Performing business analysis...")
        business_analysis = await business_analysis_plugin.analyze_image_data(image_description)
        print(f"Business analysis completed: {len(business_analysis)} characters")
        
        # Step 3: Create podcast script
        print("Step 3: Creating podcast script...")
        podcast_script = await podcast_script_plugin.create_podcast_script(business_analysis)
        print(f"Podcast script completed: {len(podcast_script)} characters")
        
        # Step 4: Format SSML
        print("Step 4: Formatting SSML...")
        formatted_ssml = ssml_plugin.format_ssml(podcast_script)
        print(f"SSML formatting completed: {len(formatted_ssml)} characters")
        
        # Step 5: Convert to speech
        print("Step 5: Converting to speech...")
        speech_result = ssml_plugin.ssml_to_speech(formatted_ssml)
        print(f"Speech synthesis result: {speech_result}")
        
        print("\n--- Semantic Kernel Workflow Finished ---")
        
    except Exception as e:
        print(f"Error during workflow execution: {str(e)}")
        import traceback
        traceback.print_exc()
        return

    # --- Post-Run Verification ---
    print(f"\n--- Post-Run Verification ---")
    if os.path.exists(OUTPUT_FILENAME):
        print(f"Success: Output audio file found at: {OUTPUT_FILENAME}")
        print(f"File size: {os.path.getsize(OUTPUT_FILENAME)} bytes")
    else:
        print(f"Error: Output audio file NOT found at the expected path: {OUTPUT_FILENAME}")
        print("Please check the logs above for errors during the analysis, formatting or synthesis tasks.")
    print(f"---------------------------\n")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())